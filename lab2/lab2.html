<!DOCTYPE html>
<html>
<head>
    <title>Nocna Scena z Ruchomymi Światłami</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="WebGLCanvas"></div>

    <script>
        var scene, camera, renderer, controls;
        var objects = [];
        var lights = [];
        var time = 0;

        initScene();
        animate();

        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000428, 10, 100);

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setClearColor(0x000428, 1); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById("WebGLCanvas").appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(0, 25, 50);
            camera.lookAt(scene.position);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            var planeGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
            var planeMaterial = new THREE.MeshPhongMaterial({color: 0x1a1a2e,shininess: 10});
            var plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -0.5 * Math.PI;
            plane.position.y = 0;
            plane.receiveShadow = true;
            scene.add(plane);

            var ambientLight = new THREE.AmbientLight(0x0a0a1a, 0.3);
            scene.add(ambientLight);

            createMovingObjects();
            createColorfulLights();
            createStars();

            window.addEventListener('resize', onWindowResize, false);
        }

        function createMovingObjects() {
            var geometries = [
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.SphereGeometry(1.5, 16, 16),
                new THREE.ConeGeometry(1, 2.5, 16),
                new THREE.TorusGeometry(1, 0.4, 16, 32),
                new THREE.OctahedronGeometry(1.5),
                new THREE.TetrahedronGeometry(1.5),
                new THREE.CylinderGeometry(0.8, 0.8, 2.5, 16)
            ];

            for (var i = 0; i < 12; i++) {
                var geometry = geometries[i % geometries.length];
                var material = new THREE.MeshPhongMaterial({
                    color: Math.random() * 0xffffff,
                    shininess: 80,
                    specular: 0xffffff
                });
                
                var mesh = new THREE.Mesh(geometry, material);
                
                var radius = 15 + Math.random() * 15;
                var angle = (i / 12) * Math.PI * 2;
                
                mesh.position.x = Math.cos(angle) * radius;
                mesh.position.z = Math.sin(angle) * radius;
                mesh.position.y = 2 + Math.random() * 3;
                mesh.castShadow = true;
                mesh.receiveShadow = true;

                mesh.userData = {
                    radius: radius,
                    angle: angle,
                    speed: 0.3 + Math.random() * 0.5,
                    ySpeed: 0.5 + Math.random() * 1.0,
                    yOffset: Math.random() * Math.PI * 2,
                    rotationSpeed: {
                        x: (Math.random() - 0.5) * 0.05,
                        y: (Math.random() - 0.5) * 0.05,
                        z: (Math.random() - 0.5) * 0.05
                    }
                };
                
                objects.push(mesh);
                scene.add(mesh);
            }
        }

        function createColorfulLights() {
            var lightColors = [
                0xff0040,  // Czerwony-różowy
                0x00ff80,  // Zielony-cyjan
                0x4080ff,  // Niebieski
                0xffff00,  // Żółty
                0xff00ff,  // Magenta
                0x00ffff,  // Cyjan
                0xff8000   // Pomarańczowy
            ];

            for (var i = 0; i < 7; i++) {
                var light = new THREE.PointLight(lightColors[i], 2, 40);
                light.castShadow = true;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                
                var radius = 20;
                var angle = (i / 7) * Math.PI * 2;
                
                light.position.x = Math.cos(angle) * radius;
                light.position.z = Math.sin(angle) * radius;
                light.position.y = 8;
                
                light.userData = {
                    radius: radius,
                    angle: angle,
                    speed: 0.4 + Math.random() * 0.3,
                    ySpeed: 0.8 + Math.random() * 0.5,
                    yOffset: Math.random() * Math.PI * 2,
                    baseY: 8
                };
                
                var sphereGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                var sphereMaterial = new THREE.MeshBasicMaterial({color: lightColors[i]});
                var lightSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(lightSphere);
                
                lights.push(light);
                scene.add(light);
            }

            var moonLight = new THREE.SpotLight(0xaaaaff, 0.5);
            moonLight.position.set(0, 50, 0);
            moonLight.angle = Math.PI / 4;
            moonLight.penumbra = 0.3;
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            scene.add(moonLight);
        }

        function createStars() {
            var starsGeometry = new THREE.BufferGeometry();
            var starPositions = [];
            
            for (var i = 0; i < 500; i++) {
                var x = (Math.random() - 0.5) * 200;
                var y = Math.random() * 50 + 30;
                var z = (Math.random() - 0.5) * 200;
                starPositions.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            
            var starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                transparent: true,
                opacity: 0.8
            });
            
            var stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            objects.forEach(function(obj) {

                obj.userData.angle += obj.userData.speed * 0.01;
                obj.position.x = Math.cos(obj.userData.angle) * obj.userData.radius;
                obj.position.z = Math.sin(obj.userData.angle) * obj.userData.radius;

                obj.position.y = 3 + Math.sin(time * obj.userData.ySpeed + obj.userData.yOffset) * 2;
                
                obj.rotation.x += obj.userData.rotationSpeed.x;
                obj.rotation.y += obj.userData.rotationSpeed.y;
                obj.rotation.z += obj.userData.rotationSpeed.z;
            });

            lights.forEach(function(light) {
                light.userData.angle -= light.userData.speed * 0.01;
                light.position.x = Math.cos(light.userData.angle) * light.userData.radius;
                light.position.z = Math.sin(light.userData.angle) * light.userData.radius;
                light.position.y = light.userData.baseY + Math.sin(time * light.userData.ySpeed + light.userData.yOffset) * 3;
            });

            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>