<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Physics Box</title>
  <link rel="stylesheet"  />
</head>
<body>
  
  <div class="viewport"></div>

  <div style="position: absolute; top: 20px; left: 20px; color: white; font-family: Arial, sans-serif; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;">
    <div style="margin-bottom: 10px; font-size: 14px;">Click to BOOM! üí•</div>
    <label for="speedControl" style="display: block; margin-bottom: 5px; font-size: 14px;">Spawn Speed:</label>
    <input type="range" id="speedControl" min="200" max="3000" value="1000" step="100" style="width: 200px;">
    <span id="speedValue" style="margin-left: 10px;">1.0s</span>
  </div>

  <script src="three.min.js"></script>
  <script src="physi.js"></script>
  <script>
    var container, scene, renderer, camera, light, ball, plane;
    var WIDTH, HEIGHT, VIEW_ANGLE, ASPECT, NEAR, FAR;

    var clock = new THREE.Clock();

    Physijs.scripts.worker = 'physijs_worker.js';
    Physijs.scripts.ammo = 'ammo.js';

    container = document.querySelector('.viewport');

    WIDTH = window.innerWidth,
    HEIGHT = window.innerHeight;

    VIEW_ANGLE = 45,
    ASPECT = WIDTH / HEIGHT,
    NEAR = 1,
    FAR = 10000;

    scene = new Physijs.Scene();
    scene.setGravity(new THREE.Vector3( 0, -50., 0 ));
    scene.addEventListener('update', function() {
        scene.simulate(undefined, 2);
    });

    renderer = new THREE.WebGLRenderer({
      antialias: true
    });

    renderer.setSize(WIDTH, HEIGHT);
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapType = THREE.PCFShadowMap;
    renderer.shadowMapAutoUpdate = true;

    container.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

    camera.position.set(60, 40, 120);
    camera.lookAt(scene.position);
    scene.add(camera);

    light = new THREE.DirectionalLight(0xffffff);

    light.position.set(0, 100, 60);
    light.castShadow = true;
    light.shadowCameraLeft = -60;
    light.shadowCameraTop = -60;
    light.shadowCameraRight = 60;
    light.shadowCameraBottom = 60;
    light.shadowCameraNear = 1;
    light.shadowCameraFar = 1000;
    light.shadowBias = -.0001
    light.shadowMapWidth = light.shadowMapHeight = 1024;
    light.shadowDarkness = .7;

    scene.add(light);

    plane = new Physijs.BoxMesh(
      new THREE.CubeGeometry(100, 100, 2, 100, 100),
      Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
          color: 0xeeeeee
        }),
        .4,
        .99
      ),
      0
    );

    plane.rotation.x = -Math.PI / 2;
    plane.rotation.y = Math.PI / 24;
    plane.receiveShadow = true;

    scene.add(plane);

    // Pude≈Çko - dno
    var boxBottom = new Physijs.BoxMesh(
      new THREE.CubeGeometry(30, 1, 30),
      Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
          color: 0x8B4513
        }),
        .4,
        .6
      ),
      0
    );
    boxBottom.position.set(0, 0.5, 0);
    boxBottom.receiveShadow = true;
    boxBottom.castShadow = true;
    scene.add(boxBottom);

    // Pude≈Çko - ≈õciana przednia
    var boxFront = new Physijs.BoxMesh(
      new THREE.CubeGeometry(30, 15, 1),
      Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
          color: 0xA0522D
        }),
        .4,
        .6
      ),
      0
    );
    boxFront.position.set(0, 7.5, 15);
    boxFront.receiveShadow = true;
    boxFront.castShadow = true;
    scene.add(boxFront);

    // Pude≈Çko - ≈õciana tylna
    var boxBack = new Physijs.BoxMesh(
      new THREE.CubeGeometry(30, 15, 1),
      Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
          color: 0xA0522D
        }),
        .4,
        .6
      ),
      0
    );
    boxBack.position.set(0, 7.5, -15);
    boxBack.receiveShadow = true;
    boxBack.castShadow = true;
    scene.add(boxBack);

    // Pude≈Çko - ≈õciana lewa
    var boxLeft = new Physijs.BoxMesh(
      new THREE.CubeGeometry(1, 15, 30),
      Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
          color: 0xA0522D
        }),
        .4,
        .6
      ),
      0
    );
    boxLeft.position.set(-15, 7.5, 0);
    boxLeft.receiveShadow = true;
    boxLeft.castShadow = true;
    scene.add(boxLeft);

    // Pude≈Çko - ≈õciana prawa
    var boxRight = new Physijs.BoxMesh(
      new THREE.CubeGeometry(1, 15, 30),
      Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
          color: 0xA0522D
        }),
        .4,
        .6
      ),
      0
    );
    boxRight.position.set(15, 7.5, 0);
    boxRight.receiveShadow = true;
    boxRight.castShadow = true;
    scene.add(boxRight);

    // TRAMPOLINA - obok pude≈Çka
    var trampoline = new Physijs.BoxMesh(
      new THREE.CubeGeometry(20, 1, 20),
      Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
          color: 0x00ff00,
          emissive: 0x003300
        }),
        .9,
        .1
      ),
      0
    );
    trampoline.position.set(35, 0.5, 0);
    trampoline.receiveShadow = true;
    trampoline.castShadow = true;
    
    // Event listener dla trampoliny - odbija kulki w g√≥rƒô
    trampoline.addEventListener('collision', function(other_object, relative_velocity, relative_rotation, contact_normal) {
      if (other_object instanceof Physijs.SphereMesh) {
        var bounceForce = new THREE.Vector3(0, 100, 0);
        other_object.applyCentralImpulse(bounceForce);
      }
    });
    
    scene.add(trampoline);

    var spawnInterval = 1000;
    var intervalId;

    function startSpawning() {
      if (intervalId) clearInterval(intervalId);
      
      intervalId = setInterval(function() {
        ball = new Physijs.SphereMesh(
          new THREE.SphereGeometry(
            Math.random() * (4 - 1) + 1,
            16,
            16
          ),
          Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
              color: 0xff0000,
              reflectivity: .8
            }),
            .4,
            .99
          ),
          1
        );

        var r = {
          x: Math.random() * (Math.PI - Math.PI / 12) + Math.PI / 12,
          y: Math.random() * (Math.PI - Math.PI / 12) + Math.PI / 12,
          z: Math.random() * (Math.PI - Math.PI / 12) + Math.PI / 12
        };

        ball.rotation.set(r.x, r.y, r.z);
        ball.position.y = 40;
        ball.castShadow = true;
        ball.receiveShadow = true;

        // Dodaj listener kolizji dla ka≈ºdej kulki
        ball.addEventListener('collision', function(other_object, relative_velocity, relative_rotation, contact_normal) {
          this.material.color.setHex(Math.random() * 0xffffff);
        });

        scene.add(ball);
      }, spawnInterval);
    }

    startSpawning();

    // Kontrola suwaka
    document.getElementById('speedControl').addEventListener('input', function(e) {
      spawnInterval = parseInt(e.target.value);
      document.getElementById('speedValue').textContent = (spawnInterval / 1000).toFixed(1) + 's';
      startSpawning();
    });

    // Nowa logika: Klikniƒôcie myszkƒÖ tworzy wybuch (impulse)
    document.addEventListener('click', function(event) {
      // Prosta metoda - wybuch od ≈õrodka sceny na zewnƒÖtrz
      for (var i = 5; i < scene.children.length; i++) {
        var obj = scene.children[i];
        if (obj instanceof Physijs.SphereMesh) {
          var direction = new THREE.Vector3();
          direction.subVectors(obj.position, new THREE.Vector3(0, 10, 0));
          direction.normalize();
          
          var forceMagnitude = 100;
          var force = direction.multiplyScalar(forceMagnitude);
          obj.applyCentralImpulse(force);
        }
      }
    });

    render();
    scene.simulate()

    function render() {
      for (var i = 5; i < scene.children.length - 5; i++) {
        var obj = scene.children[i];

        if (obj.position.y <= -50) {
          scene.remove(obj);
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
  </script>
</body>
</html>